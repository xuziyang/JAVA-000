
## 什么是线程安全？

“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的”   
                                        <p align="right">--Brian Goetz</p>    

Brian Goetz描述的线程安全，在现实情况下是很难实现的，一般情况下在其他限制条件不变的情况下，对“这个对象的单次调用”可以获得正确的结果，那么就认为他是线程安全的。对“这个对象的单次调用”的线程安全，我们叫做“相对线程安全”，java并发集合中的类，大部分都是“相对线程安全的”，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。

## jdk6后，对synchronized的锁进行优化



## 产生死锁的四个必要条件：  
1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。


## 如何避免死锁
破坏除了互斥外的三个条件中的一个，就可以避免死锁  
- 占有且等待，可以一次性申请所有资源
- 不可抢占，可以主动放弃自己占有的资源
- 循环等待，可以按顺序申请字段

## wait和sleep的区别
- wait 需要写在sychronized代码块内，sleep不需要
- wait 会释放锁，sleep不会
- wait 需要其他线程调用notify方法唤醒

## 并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：
- 永远只在更新对象的成员变量时加锁
- 永远只在访问可变的成员变量时加锁
- 永远不在调用其他对象的方法时加锁

## notify() 和notifyAll() 使用策略

尽量使用notifyAll(),如果使用notify()需满足以下三个条件：  
1. 所有线程拥有相同的等待条件
2. 所有的线程被唤醒后，执行相同的操作
3. 只需要唤醒一个线程


## ReadWriteLock VS StampedLock
- 都适用于读多写少的场景，StampedLock的乐观锁机制，性能比ReadWriteLock好
- StampedLock 的悲观读锁、写锁都不支持条件变量
- StampedLock中断操作会造成cpu100

